<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Интерактивный Тест</title>
    <!-- Подключение Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Настройка шрифта Inter -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f9;
        }
        /* Пользовательский CSS для изменения курсора */
        .correct-answer-visible:hover {
            cursor: help !important; /* Курсор меняется на 'help' (знак вопроса) */
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.7);
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="app" class="max-w-4xl mx-auto bg-white p-6 md:p-10 rounded-xl shadow-2xl space-y-8">
        <h1 class="text-3xl font-extrabold text-gray-900 border-b pb-3 mb-6">Интерактивный Тест с Сохранением Данных</h1>

        <div id="status-message" class="p-4 rounded-lg text-sm font-medium hidden"></div>
        <div id="loader" class="text-center text-blue-600 font-semibold">Загрузка данных и аутентификация...</div>

        <div id="test-container" class="space-y-12 hidden">
            <!-- Вопросы будут загружены сюда -->
        </div>

        <div id="controls" class="flex flex-col sm:flex-row gap-4 pt-6 border-t">
            <button id="submit-btn" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200 shadow-md disabled:opacity-50" disabled>
                Отправить ответы и сохранить прогресс
            </button>
            <button id="admin-delete-btn" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg transition duration-200 shadow-md disabled:opacity-50">
                Имитация: Админ отправил ответ (Удалить прогресс)
            </button>
        </div>

        <div id="debug-info" class="text-xs text-gray-500 pt-8 border-t mt-8">
            <h3 class="font-bold mb-2">Отладочная информация:</h3>
            <p>ID Приложения: <span id="app-id-display"></span></p>
            <p>ID Пользователя: <span id="user-id-display"></span></p>
            <p>Статус сохранения: <span id="save-status">Ожидание действия...</span></p>
        </div>
    </div>

    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Включение логов Firestore для отладки
        setLogLevel('Debug');

        // Глобальные переменные, предоставленные Canvas
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Переменные Firebase
        let app;
        let db;
        let auth;
        let userId = null;
        let submissionId = 'user_submission_' + Date.now(); // Уникальный ID для этой сессии/попытки
        let isAuthReady = false;

        // Элементы DOM
        const appDisplay = document.getElementById('app-id-display');
        const userDisplay = document.getElementById('user-id-display');
        const loader = document.getElementById('loader');
        const testContainer = document.getElementById('test-container');
        const statusMessage = document.getElementById('status-message');
        const saveStatusDisplay = document.getElementById('save-status');
        const submitBtn = document.getElementById('submit-btn');
        const adminDeleteBtn = document.getElementById('admin-delete-btn');

        // Моковый набор вопросов (включая URL изображения)
        const mockQuestions = [
            {
                id: 1,
                question: "Какое геометрическое тело представлено на изображении?",
                imageUrl: "https://placehold.co/400x200/4c77aa/ffffff?text=Трехмерная+Фигура",
                options: ["Куб", "Пирамида", "Сфера", "Цилиндр"],
                correctAnswer: "Сфера",
                userAnswer: null
            },
            {
                id: 2,
                question: "Кто является автором романа 'Война и мир'?",
                imageUrl: "https://placehold.co/400x200/8d6e63/ffffff?text=Старинная+Книга",
                options: ["Ф.М. Достоевский", "Л.Н. Толстой", "А.П. Чехов", "И.С. Тургенев"],
                correctAnswer: "Л.Н. Толстой",
                userAnswer: null
            },
             {
                id: 3,
                question: "Какой элемент имеет атомный номер 1?",
                imageUrl: "https://placehold.co/400x200/9ccc65/ffffff?text=Атом",
                options: ["Кислород", "Гелий", "Водород", "Углерод"],
                correctAnswer: "Водород",
                userAnswer: null
            }
        ];

        // --- Firebase Инициализация и Аутентификация ---

        async function initFirebase() {
            if (Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase config is missing.");
                showStatus('Ошибка: Конфигурация Firebase не найдена.', 'bg-red-100 text-red-800');
                loader.textContent = "Ошибка загрузки: Проверьте конфигурацию Firebase.";
                return;
            }

            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            appDisplay.textContent = appId;

            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase Auth Error:", error);
                showStatus(`Ошибка аутентификации: ${error.message}`, 'bg-red-100 text-red-800');
            }

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    userDisplay.textContent = userId;
                } else {
                    // Используем случайный ID для неаутентифицированных
                    userId = crypto.randomUUID();
                    userDisplay.textContent = `Анонимный (${userId.substring(0, 8)}...)`;
                }
                isAuthReady = true;
                loader.classList.add('hidden');
                testContainer.classList.remove('hidden');
                submitBtn.disabled = false;
                loadProgress(); // Попытка загрузить прогресс после аутентификации
                renderTest();
            });
        }

        // --- Функции Базы Данных (Firestore) ---

        // Приватный путь для сохранения прогресса пользователя
        function getSubmissionDocRef() {
            if (!userId) throw new Error("User ID is not defined.");
            // Путь: /artifacts/{appId}/users/{userId}/test_submissions/{submissionId}
            return doc(db, 'artifacts', appId, 'users', userId, 'test_submissions', submissionId);
        }

        /**
         * Сохраняет текущий прогресс теста на сервере.
         * Используется для сохранения данных, когда клиент "обновляет страницу".
         * @param {boolean} isSubmitted - Флаг, указывающий, что тест отправлен.
         */
        async function saveProgress(isSubmitted = false) {
            if (!isAuthReady || !db || !userId) return;

            saveStatusDisplay.textContent = 'Сохранение...';

            // Очищаем данные от лишнего (например, imageUrl, чтобы не хранить дубликаты)
            const submissionData = mockQuestions.map(q => ({
                id: q.id,
                userAnswer: q.userAnswer,
                isSubmitted: isSubmitted
            }));

            const dataToSave = {
                timestamp: Date.now(),
                userId: userId,
                questions: submissionData,
                isSubmitted: isSubmitted
            };

            try {
                const docRef = getSubmissionDocRef();
                await setDoc(docRef, dataToSave);
                saveStatusDisplay.textContent = isSubmitted ? 'Ответы успешно отправлены!' : 'Прогресс сохранен.';
                showStatus(isSubmitted ? 'Ответы отправлены и прогресс сохранен на сервере!' : 'Прогресс автоматически сохранен.', 'bg-green-100 text-green-800');
            } catch (error) {
                console.error("Ошибка сохранения прогресса:", error);
                saveStatusDisplay.textContent = 'Ошибка сохранения!';
                showStatus('Ошибка сохранения прогресса. См. консоль.', 'bg-red-100 text-red-800');
            }
        }

        /**
         * Загружает ранее сохраненный прогресс из Firestore.
         */
        async function loadProgress() {
             if (!isAuthReady || !db || !userId) return;

             try {
                const docRef = getSubmissionDocRef();
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    data.questions.forEach(savedQ => {
                        const localQ = mockQuestions.find(q => q.id === savedQ.id);
                        if (localQ) {
                            localQ.userAnswer = savedQ.userAnswer;
                        }
                    });
                    
                    // Если тест был отправлен, показываем правильные ответы и блокируем форму
                    if (data.isSubmitted) {
                        finalizeTest();
                    }

                    showStatus('Прогресс загружен с сервера. Продолжайте.', 'bg-blue-100 text-blue-800');
                    renderTest(); // Перерисовываем тест с загруженными ответами
                } else {
                    showStatus('Новый тест. Прогресс не найден.', 'bg-gray-100 text-gray-800');
                }
            } catch (error) {
                console.error("Ошибка загрузки прогресса:", error);
            }
        }

        /**
         * Имитация действия администратора: удаление прогресса.
         * Выполняет требование: "исчезает на сервере, когда админ отправил ответ"
         */
        async function deleteProgress() {
            if (!isAuthReady || !db || !userId) return;

            try {
                const docRef = getSubmissionDocRef();
                await deleteDoc(docRef);
                
                // Сброс локального состояния
                mockQuestions.forEach(q => q.userAnswer = null);
                submissionId = 'user_submission_' + Date.now(); // Новый ID для новой попытки
                
                showStatus('Имитация: Прогресс был удален администратором. Начните тест заново.', 'bg-yellow-100 text-yellow-800');
                saveStatusDisplay.textContent = 'Ожидание действия...';
                renderTest(); // Перерисовываем тест
                submitBtn.disabled = false;
                submitBtn.textContent = 'Отправить ответы и сохранить прогресс';
                adminDeleteBtn.disabled = true; // Сбрасываем кнопку удаления
            } catch (error) {
                 console.error("Ошибка удаления прогресса:", error);
                 showStatus('Ошибка удаления прогресса. См. консоль.', 'bg-red-100 text-red-800');
            }
        }

        // --- Логика Интерфейса и Рендеринга ---

        function showStatus(message, className) {
            statusMessage.className = `p-4 rounded-lg text-sm font-medium ${className}`;
            statusMessage.textContent = message;
            statusMessage.classList.remove('hidden');
        }

        /**
         * Обновляет ответ пользователя локально.
         */
        function handleOptionChange(questionId, answer) {
            const question = mockQuestions.find(q => q.id === questionId);
            if (question) {
                question.userAnswer = answer;
                // Автоматическое сохранение прогресса при каждом изменении (имитация "обновления страницы")
                saveProgress(false); 
            }
        }

        /**
         * Рендерит вопросы теста на основе mockQuestions.
         */
        function renderTest() {
            testContainer.innerHTML = '';
            
            const isSubmitted = mockQuestions.every(q => q.userAnswer !== null && submitBtn.disabled);

            mockQuestions.forEach(q => {
                const questionElement = document.createElement('div');
                questionElement.className = 'p-6 bg-gray-50 rounded-xl shadow-lg border border-gray-200 space-y-4';
                questionElement.innerHTML = `
                    <h2 class="text-xl font-bold text-gray-800 mb-4">${q.id}. ${q.question}</h2>
                    <!-- Картинка приходит из тестов (Пункт 1) -->
                    <img src="${q.imageUrl}" alt="Изображение для вопроса ${q.id}" class="w-full h-auto object-cover rounded-lg shadow-inner border border-gray-300" onerror="this.onerror=null;this.src='https://placehold.co/400x200/cccccc/000000?text=Ошибка+Загрузки+Изображения';">
                    
                    <div class="options-group space-y-3" data-question-id="${q.id}">
                        ${q.options.map(option => {
                            const isCorrect = isSubmitted && option === q.correctAnswer;
                            const isSelected = q.userAnswer === option;
                            
                            let classes = 'p-3 rounded-lg border-2 transition duration-150 ease-in-out cursor-pointer hover:shadow-md';
                            
                            if (isSubmitted) {
                                // Если тест отправлен, показываем правильный/неправильный ответ
                                if (isCorrect) {
                                    classes += ' bg-green-100 border-green-500 font-semibold correct-answer-visible';
                                } else if (isSelected) {
                                    classes += ' bg-red-100 border-red-500';
                                } else {
                                    classes += ' border-gray-300 text-gray-700';
                                }
                            } else {
                                // Во время прохождения теста
                                classes += isSelected ? ' bg-indigo-100 border-indigo-500 font-semibold' : ' border-gray-300 hover:bg-gray-100';
                            }
                            
                            // Пункт 4: Изменение курсора на правильном ответе (только после отправки)
                            // Класс correct-answer-visible делает это через CSS при наведении
                            const cursorClass = isCorrect ? 'correct-answer-visible' : '';

                            return `
                                <div 
                                    class="${classes} ${cursorClass}" 
                                    data-answer="${option}"
                                    data-question-id="${q.id}"
                                    onclick="window.handleOptionClick(${q.id}, '${option.replace(/'/g, "\\'")}')"
                                    ${isSubmitted ? 'style="pointer-events: none;"' : ''}
                                >
                                    ${option}
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                testContainer.appendChild(questionElement);
            });

            // Если тест отправлен, активируем кнопку имитации удаления
            if (isSubmitted) {
                adminDeleteBtn.disabled = false;
            }
        }

        // --- Обработчики Событий ---

        // Переносим функцию в глобальную область видимости для обработки событий DOM
        window.handleOptionClick = (questionId, answer) => {
            const questionDiv = document.querySelector(`.options-group[data-question-id="${questionId}"]`);
            if (questionDiv.getAttribute('style') && questionDiv.getAttribute('style').includes('none')) {
                return; // Блокируем клики после отправки
            }

            handleOptionChange(questionId, answer);
            renderTest(); // Перерисовать, чтобы показать выбранный ответ
        };
        
        // Финализация теста (отправка на сервер)
        function finalizeTest() {
            submitBtn.disabled = true;
            submitBtn.textContent = 'Ответы отправлены (Тест завершен)';
            // Убеждаемся, что прогресс сохранен как 'отправленный'
            saveProgress(true); 
            // Активируем кнопку имитации администратора
            adminDeleteBtn.disabled = false;

            // Блокируем дальнейший ввод и показываем результаты
            mockQuestions.forEach(q => q.userAnswer = q.userAnswer || 'Не отвечено');
            renderTest();
        }

        submitBtn.addEventListener('click', finalizeTest);
        adminDeleteBtn.addEventListener('click', deleteProgress);


        // Инициализация
        initFirebase();
    </script>
</body>
</html>
